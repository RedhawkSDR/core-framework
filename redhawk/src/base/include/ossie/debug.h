/*
 * This file is protected by Copyright. Please refer to the COPYRIGHT file 
 * distributed with this source distribution.
 * 
 * This file is part of REDHAWK core.
 * 
 * REDHAWK core is free software: you can redistribute it and/or modify it 
 * under the terms of the GNU Lesser General Public License as published by the 
 * Free Software Foundation, either version 3 of the License, or (at your 
 * option) any later version.
 * 
 * REDHAWK core is distributed in the hope that it will be useful, but WITHOUT 
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License 
 * for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License 
 * along with this program.  If not, see http://www.gnu.org/licenses/.
 */


#ifndef DEBUG_H
#define DEBUG_H

#include<iostream>
#include<fstream>
#include<string>
#include<cstring>

//
//  Disable Redhawk Logger class
//
#ifdef  NO_RH_LOGGER

//
// include prior generation macros if Redhawk Logging is disabled
//

#include <ossie/debug_old.h>

#else    //  NO_RH_LOGGER NOT SET   (default), 

//
//  Begin Macros to use RedHawk Logging Abstraction
//
#include <sstream>
#include "ossie/logging/rh_logger.h"


#define ENABLE_LOGGING \
    private: \
    static rh_logger::LoggerPtr __logger;

#define PREPARE_LOGGING(classname) \
    rh_logger::LoggerPtr classname::__logger(rh_logger::Logger::getResourceLogger(#classname));


#define PREPARE_CF_LOGGING(classname) \
    rh_logger::LoggerPtr classname::__logger(rh_logger::Logger::getLogger(#classname));


#define PREPARE_ALT_LOGGING(classname, loggername) \
    rh_logger::LoggerPtr classname::__logger(rh_logger::Logger::getLogger(#loggername));

#define CREATE_LOGGER(classname) \
    class classname \
    { \
        public: \
	static rh_logger::LoggerPtr __logger; \
    }; \
    rh_logger::LoggerPtr classname::__logger(rh_logger::Logger::getLogger(#classname));

#define _RH_LOG( level, logger, msg)	\
  if ( logger && logger->is##level##Enabled() ) {			\
    std::ostringstream _msg;						\
    _msg <<  msg;				          		\
    logger->handleLogEvent( rh_logger::Level::get##level(), _msg.str(), rh_logger::spi::LocationInfo(__FILE__,__PRETTY_FUNCTION__,__LINE__) ); \
  }


//
//  Gen 1 Macros, use classname to resolve logger instance to use
//
#define LOG_TRACE(classname, expression)  _RH_LOG( Trace,  classname::__logger, expression)
#define LOG_DEBUG(classname, expression)  _RH_LOG( Debug,  classname::__logger, expression)
#define LOG_INFO(classname, expression)   _RH_LOG( Info,   classname::__logger, expression)
#define LOG_WARN(classname, expression)   _RH_LOG( Warn,   classname::__logger, expression)
#define LOG_ERROR(classname, expression)  _RH_LOG( Error,   classname::__logger, expression)
#define LOG_FATAL(classname, expression)  _RH_LOG( Fatal,   classname::__logger, expression)

//
//  Gen 2 Macros, use specified logger instance to use
//
#define RH_TRACE( logger, expression )  _RH_LOG( Trace,  logger, expression)
#define RH_DEBUG( logger, expression )  _RH_LOG( Debug,  logger, expression)
#define RH_INFO( logger, expression )   _RH_LOG( Info,   logger, expression)
#define RH_WARN( logger, expression )   _RH_LOG( Warn,   logger, expression)
#define RH_ERROR( logger, expression )  _RH_LOG( Error,  logger, expression)
#define RH_FATAL( logger, expression )  _RH_LOG( Fatal,  logger, expression)


//
//  Gen 3 Macros, use named logger to lookup logger instance to use
//
#define RH_NL_TRACE( loggerName, expression )  _RH_LOG( Trace,  rh_logger::Logger::getLogger(loggerName), expression)
#define RH_NL_DEBUG( loggerName, expression )  _RH_LOG( Debug,  rh_logger::Logger::getLogger(loggerName), expression)
#define RH_NL_INFO( loggerName, expression )   _RH_LOG( Info,   rh_logger::Logger::getLogger(loggerName), expression)
#define RH_NL_WARN( loggerName, expression )   _RH_LOG( Warn,   rh_logger::Logger::getLogger(loggerName), expression)
#define RH_NL_ERROR( loggerName, expression )  _RH_LOG( Error,  rh_logger::Logger::getLogger(loggerName), expression)
#define RH_NL_FATAL( loggerName, expression )  _RH_LOG( Fatal,  rh_logger::Logger::getLogger(loggerName), expression)



#ifdef HAVE_LOG4CXX
#if  defined(LOG4CXX_TRACE) || defined(LOG4CXX_DEBUG)  || defined(LOG4CXX_INFO)  || defined(LOG4CXX_WARN)  || defined(LOG4CXX_ERROR)  || defined(LOG4CXX_FATAL) 
#warning  "For non-ENABLE_LOGGING logger objects, use rh_logger::Logger::getLogger method and RH_XXXX log macros"
#endif 
#else
#define LOG4CXX_TRACE( logger, expression )  _RH_LOG( Trace,  logger, expression)
#define LOG4CXX_DEBUG( logger, expression )  _RH_LOG( Debug,  logger, expression)
#define LOG4CXX_INFO( logger, expression )   _RH_LOG( Info,   logger, expression)
#define LOG4CXX_WARN( logger, expression )   _RH_LOG( Warn,   logger, expression)
#define LOG4CXX_ERROR( logger, expression )  _RH_LOG( Error,  logger, expression)
#define LOG4CXX_FATAL( logger, expression )  _RH_LOG( Fatal,  logger, expression)
#endif


#endif    //  NO_RH_LOGGER NOT SET   (default)

/*
* Provide a standardized mechanism for  TRACING into and out of functions so
* they all look similar.  Unlike LOG_TRACE, these are only included
* in the code if DEBUG is defined
*/
#ifdef ENABLE_TRACE
#define TRACE_ENTER(classname) \
    LOG_TRACE(classname, "Entering " << #classname << "." << __PRETTY_FUNCTION__ << " [" << __FILE__ << ":" << __LINE__ << "]")

#define TRACE_EXIT(classname) \
    LOG_TRACE(classname, "Exiting " << #classname << "." << __PRETTY_FUNCTION__ << " [" << __FILE__ << ":" << __LINE__ << "]")

#define RH_TRACE_ENTER(logger) \
    RH_TRACE(logger, "Entering " << __PRETTY_FUNCTION__ << " [" << __FILE__ << ":" << __LINE__ << "]")


#define RH_TRACE_EXIT(logger) \
  RH_TRACE(logger, "Exiting " << __PRETTY_FUNCTION__ << " [" << __FILE__ << ":" << __LINE__ << "]")


#define RH_NL_TRACE_ENTER(loggerName) \
    RH_NL_TRACE(#loggerName, "Entering " << #loggerName << "." << __PRETTY_FUNCTION__ << " [" << __FILE__ << ":" << __LINE__ << "]")


#define RH_NL_TRACE_EXIT(loggerName) \
  RH_NL_TRACE(#loggerName, "Exiting " << #loggerName << "." << __PRETTY_FUNCTION__ << " [" << __FILE__ << ":" << __LINE__ << "]")

#else
#define TRACE_ENTER(classname)
#define TRACE_EXIT(classname)
#define RH_TRACE_ENTER(logger)
#define RH_TRACE_EXIT(logger)
#define RH_NL_TRACE_ENTER(classname)
#define RH_NL_TRACE_EXIT(classname)

#endif

/*
* Provide standardized exception handling for common calls.
*/
#define CATCH_LOG_EXCEPTION(classname, expression, levelname) \
    catch( std::exception& ex ) { \
        LOG_##levelname(classname, expression << "; std::exception info: " << ex.what()) \
    } \
    catch( CORBA::Exception& ex ) { \
        LOG_##levelname(classname, expression << "; CORBA::Exception name: " << ex._name()) \
    } \
    catch( ... ) { \
        LOG_##levelname(classname, expression << "; unknown exception") \
    }

#define CATCH_RH_EXCEPTION(logger, expression, levelname) \
    catch( std::exception& ex ) { \
        RH_##levelname(logger, expression << "; std::exception info: " << ex.what()) \
    } \
    catch( CORBA::Exception& ex ) { \
        RH_##levelname(logger, expression << "; CORBA::Exception name: " << ex._name()) \
    } \
    catch( ... ) { \
        RH_##levelname(logger, expression << "; unknown exception") \
    }

#define CATCH_LOG_TRACE(classname, expression) CATCH_LOG_EXCEPTION(classname, expression, TRACE)
#define CATCH_LOG_DEBUG(classname, expression) CATCH_LOG_EXCEPTION(classname, expression, DEBUG)
#define CATCH_LOG_INFO(classname, expression) CATCH_LOG_EXCEPTION(classname, expression, INFO)
#define CATCH_LOG_WARN(classname, expression) CATCH_LOG_EXCEPTION(classname, expression, WARN)
#define CATCH_LOG_ERROR(classname, expression) CATCH_LOG_EXCEPTION(classname, expression, ERROR)
#define CATCH_LOG_FATAL(classname, expression) CATCH_LOG_EXCEPTION(classname, expression, FATAL)

#define CATCH_RH_TRACE(logger, expression) CATCH_RH_EXCEPTION(logger, expression, TRACE)
#define CATCH_RH_DEBUG(logger, expression) CATCH_RH_EXCEPTION(logger, expression, DEBUG)
#define CATCH_RH_INFO(logger, expression) CATCH_RH_EXCEPTION(logger, expression, INFO)
#define CATCH_RH_WARN(logger, expression) CATCH_RH_EXCEPTION(logger, expression, WARN)
#define CATCH_RH_ERROR(logger, expression) CATCH_RH_EXCEPTION(logger, expression, ERROR)
#define CATCH_RH_FATAL(logger, expression) CATCH_RH_EXCEPTION(logger, expression, FATAL)

/*
* Provide standardized exception handling for catching and throwing a new exception.
*/
#define CATCH_THROW_LOG_EXCEPTION(classname, expression, levelname, newexception) \
    catch( std::exception& ex ) { \
        LOG_##levelname(classname, expression << "; std::exception info: " << ex.what()) \
        throw(newexception); \
    } \
    catch( CORBA::Exception& ex ) { \
        LOG_##levelname(classname, expression << "; CORBA::Exception name: " << ex._name()) \
        throw(newexception); \
    } \
    catch( ... ) { \
        LOG_##levelname(classname, expression << "; unknown exception") \
        throw(newexception); \
    }

#define CATCH_THROW_RH_EXCEPTION(logger, expression, levelname, newexception) \
    catch( std::exception& ex ) { \
        RH_##levelname(logger, expression << "; std::exception info: " << ex.what()) \
        throw(newexception); \
    } \
    catch( CORBA::Exception& ex ) { \
        RH_##levelname(logger, expression << "; CORBA::Exception name: " << ex._name()) \
        throw(newexception); \
    } \
    catch( ... ) { \
        RH_##levelname(logger, expression << "; unknown exception") \
        throw(newexception); \
    }

#define CATCH_THROW_LOG_TRACE(classname, expression, newexception) CATCH_THROW_LOG_EXCEPTION(classname, expression, TRACE, newexception)
#define CATCH_THROW_LOG_DEBUG(classname, expression, newexception) CATCH_THROW_LOG_EXCEPTION(classname, expression, DEBUG, newexception)
#define CATCH_THROW_LOG_INFO(classname, expression, newexception) CATCH_THROW_LOG_EXCEPTION(classname, expression, INFO, newexception)
#define CATCH_THROW_LOG_WARN(classname, expression, newexception) CATCH_THROW_LOG_EXCEPTION(classname, expression, WARN, newexception)
#define CATCH_THROW_LOG_ERROR(classname, expression, newexception) CATCH_THROW_LOG_EXCEPTION(classname, expression, ERROR, newexception)
#define CATCH_THROW_LOG_FATAL(classname, expression, newexception) CATCH_THROW_LOG_EXCEPTION(classname, expression, FATAL, newexception)

#define CATCH_THROW_RH_TRACE(logger, expression, newexception) CATCH_THROW_RH_EXCEPTION(logger, expression, TRACE, newexception)
#define CATCH_THROW_RH_DEBUG(logger, expression, newexception) CATCH_THROW_RH_EXCEPTION(logger, expression, DEBUG, newexception)
#define CATCH_THROW_RH_INFO(logger, expression, newexception) CATCH_THROW_RH_EXCEPTION(logger, expression, INFO, newexception)
#define CATCH_THROW_RH_WARN(logger, expression, newexception) CATCH_THROW_RH_EXCEPTION(logger, expression, WARN, newexception)
#define CATCH_THROW_RH_ERROR(logger, expression, newexception) CATCH_THROW_RH_EXCEPTION(logger, expression, ERROR, newexception)
#define CATCH_THROW_RH_FATAL(logger, expression, newexception) CATCH_THROW_RH_EXCEPTION(logger, expression, FATAL, newexception)

/*
* Provide standardized exception handling for catching and rethrowing.
*/
#define CATCH_RETHROW_LOG_EXCEPTION(classname, expression, levelname) \
    catch( std::exception& ex ) { \
        LOG_##levelname(classname, expression << "; std::exception info: " << ex.what()) \
        throw; \
    } \
    catch( CORBA::Exception& ex ) { \
        LOG_##levelname(classname, expression << "; CORBA::Exception name: " << ex._name()) \
        throw; \
    } \
    catch( ... ) { \
        LOG_##levelname(classname, expression << "; unknown exception") \
        throw; \
    }

#define CATCH_RETHROW_RH_EXCEPTION(logger, expression, levelname) \
    catch( std::exception& ex ) { \
        RH_##levelname(logger, expression << "; std::exception info: " << ex.what()) \
        throw; \
    } \
    catch( CORBA::Exception& ex ) { \
        RH_##levelname(logger, expression << "; CORBA::Exception name: " << ex._name()) \
        throw; \
    } \
    catch( ... ) { \
        RH_##levelname(logger, expression << "; unknown exception") \
        throw; \
    }

#define CATCH_RETHROW_LOG_TRACE(classname, expression) CATCH_RETHROW_LOG_EXCEPTION(classname, expression, TRACE)
#define CATCH_RETHROW_LOG_DEBUG(classname, expression) CATCH_RETHROW_LOG_EXCEPTION(classname, expression, DEBUG)
#define CATCH_RETHROW_LOG_INFO(classname, expression) CATCH_RETHROW_LOG_EXCEPTION(classname, expression, INFO)
#define CATCH_RETHROW_LOG_WARN(classname, expression) CATCH_RETHROW_LOG_EXCEPTION(classname, expression, WARN)
#define CATCH_RETHROW_LOG_ERROR(classname, expression) CATCH_RETHROW_LOG_EXCEPTION(classname, expression, ERROR)
#define CATCH_RETHROW_LOG_FATAL(classname, expression) CATCH_RETHROW_LOG_EXCEPTION(classname, expression, FATAL)

#define CATCH_RETHROW_RH_TRACE(logger, expression) CATCH_RETHROW_RH_EXCEPTION(logger, expression, TRACE)
#define CATCH_RETHROW_RH_DEBUG(logger, expression) CATCH_RETHROW_RH_EXCEPTION(logger, expression, DEBUG)
#define CATCH_RETHROW_RH_INFO(logger, expression) CATCH_RETHROW_RH_EXCEPTION(logger, expression, INFO)
#define CATCH_RETHROW_RH_WARN(logger, expression) CATCH_RETHROW_RH_EXCEPTION(logger, expression, WARN)
#define CATCH_RETHROW_RH_ERROR(logger, expression) CATCH_RETHROW_RH_EXCEPTION(logger, expression, ERROR)
#define CATCH_RETHROW_RH_FATAL(logger, expression) CATCH_RETHROW_RH_EXCEPTION(logger, expression, FATAL)


/*
 * Provide a backwards compatible macro.
 * THIS MACRO SHOULD BE AVOIDED FOR ALL NEW DEVELOPMENT
 */
#define DEBUG(level, classname, expression) LOG_DEBUG(classname, expression)


#endif
