/*
 * This file is protected by Copyright. Please refer to the COPYRIGHT file
 * distributed with this source distribution.
 *
 * This file is part of REDHAWK bulkioInterfaces.
 *
 * REDHAWK bulkioInterfaces is free software: you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation, either version 3 of the License, or (at your
 * option) any later version.
 *
 * REDHAWK bulkioInterfaces is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
 * for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see http://www.gnu.org/licenses/.
 */

#ifndef __bulkio_datablock_h
#define __bulkio_datablock_h

#include <list>
#include <complex>

#include <boost/shared_ptr.hpp>

#include <ossie/shared_buffer.h>
#include <ossie/bitbuffer.h>

#include <BULKIO/bulkioDataTypes.h>
#include "bulkio_base.h"

namespace bulkio {

    class StreamDescriptor;

    /**
     * @brief  Extended time stamp container.
     *
     * SampleTimestamp adds additional context to a BULKIO::PrecisionUTCTime
     * time stamp. When data is read from an sample-oriented input stream, it
     * may span more than one packet, or its start may not be on a packet
     * boundary. In these cases, the @a offset and @a synthetic fields allow
     * more sophisticated handling of time information.
     *
     * The @a offset indicates at which sample @a time applies. If the sample
     * data is complex, @a offset should be interpreted in terms of complex
     * samples (i.e., two real values per index).
     *
     * A %SampleTimestamp is considered synthetic if it was generated by an
     * input stream because there was no received time stamp available at that
     * sample offset. This occurs when the prior read did not end on a packet
     * boundary; only the first time stamp in a DataBlock can be synthetic.
     */
    struct SampleTimestamp
    {
        /**
         * @brief  Constructor.
         * @param time       Time stamp.
         * @param offset     Sample offset.
         * @param synthetic  False if @p time was received, true if
         *                   interpolated.
         */
        SampleTimestamp(const BULKIO::PrecisionUTCTime& time, size_t offset=0, bool synthetic=false) :
            time(time),
            offset(offset),
            synthetic(synthetic)
        {
        }

        /// @brief  The time at which the referenced sample was created.
        BULKIO::PrecisionUTCTime time;

        /// @brief  The 0-based index of the sample at which @a time applies.
        size_t offset;

        /// @brief  Indicates whether @a time was interpolated.
        bool synthetic;
    };

    /**
     * @brief  Container for sample data and stream metadata read from an
     *         input stream.
     * @headerfile  bulkio_datablock.h <bulkio/bulkio_datablock.h>
     *
     * %DataBlock is a smart pointer-based class that encapsulates the result
     * of a read operation on an input stream. It contains both data, which
     * varies with the input stream type, and metadata, including signal-
     * related information (SRI).
     *
     * @warning  Do not declare instances of this template class directly in user
     *           code; the template parameter and class name are not considered
     *           API. Use the type-specific @c typedef instead, such as
     *           bulkio::FloatDataBlock, or the nested @c typedef BlockType from
     *           an %InputStream.
     *
     * DataBlocks have reference semantics; in other words, assigning one block
     * to another does not make a copy but rather shares the same sample data
     * and metadata. When the last reference expires, the memory is released to
     * the system to prevent memory leaks. Additionally, blocks are inexpensive
     * to return by value, reassign, or store in nested data types.
     *
     * The default constructor creates an invalid (null) block. Likewise, input
     * stream read operations may return an invalid block if the operation
     * cannot be completed. When receiving a data block, you must always check
     * for validity before accessing the sample data or metadata:
     * @code
     *   if (!block) {
     *     // handle failure
     *   } else {
     *     // access data and metadata
     *   }
     * @endcode
     *
     * While it is possible to generate DataBlocks in user code, they are usually
     * obtained by reading from an input stream.
     * @see  InputStream::read
     * @see  InputStream::tryread
     */
    template <class T>
    class DataBlock
    {
    public:
        /**
         * @brief  Default constructor.
         * @see  InputStream::read
         * @see  InputStream::tryread
         *
         * Create a null block. This block has no data nor metadata associated
         * with it. No methods may be called on a null %DataBlock except for
         * boolean checks, which will always indicate that the block is not
         * valid, and operator==, which returns true if and only if the other
         * %DataBlock is also null.
         *
         * DataBlocks are typically obtained by reading from an input stream.
         */
        DataBlock();

        /**
         * @brief  Construct a %DataBlock with data.
         * @param sri    Stream descriptor for the data.
         * @param buffer The block data.
         * 
         * Creates a new, valid data block that references the data contained
         * in @a buffer.
         *
         * @note  This method is typically used by input streams.
         */
        explicit DataBlock(const StreamDescriptor& sri, const T& buffer=T());
      
        /**
         * @brief  Copies this block's data and metadata.
         * @returns  A new block.
         *
         * Makes a complete copy of this block, which returns a unique block
         * that does not share this block's data or metadata.
         *
         * If this block is invalid, returns a new null block.
         */
        DataBlock copy() const;

        /**
         * @brief  Gets the stream metadata.
         * @returns  Read-only reference to stream SRI.
         * @pre  Block is valid.
         *
         * The SRI represents the stream metadata at the time the block was
         * read.
         */
        const BULKIO::StreamSRI& sri() const;

        /**
         * @brief  Gets the X-axis delta.
         * @returns  The distance between two adjacent samples in the X
         *           direction.
         * @pre  Block is valid.
         *
         * Because the X-axis is commonly in terms of time (that is,
         * @c sri.xunits is @c BULKIO::UNITS_TIME), this is typically the
         * reciprocal of the sample rate.
         */
        double xdelta() const;

        /**
         * @brief  Read-only access to block data.
         * @returns  Read-only reference to the data buffer.
         * @pre  Block is valid.
         */
        const T& buffer() const;

        /**
         * @brief  Replaces the data contents of this block.
         * @param other  New data.
         * @pre  Block is valid.
         *
         * @note  This method is typically used by InputStream.
         */
        void buffer(const T& other);

        /**
         * @brief  Checks whether the SRI has changed since the last read from
         *         the same stream.
         * @returns  True if the SRI has changed. False is SRI is unchanged.
         * @pre  Block is valid.
         * @see  sriChangeFlags()
         */
        bool sriChanged() const;

        /**
         * @brief  Checks which SRI fields have changed since the last read
         *         from the same stream.
         * @returns  Bit mask representing changed fields.
         * @pre  Block is valid.
         * @see  sriChanged()
         *
         * If no SRI change has occurred since the last read, the returned
         * value is @c bulkio::sri::NONE (equal to 0). Otherwise, the returned
         * value is the bitwise OR of one or more of the following flags:
         *   @li @c bulkio::sri::HVERSION
         *   @li @c bulkio::sri::XSTART
         *   @li @c bulkio::sri::XDELTA
         *   @li @c bulkio::sri::XUNITS
         *   @li @c bulkio::sri::SUBSIZE
         *   @li @c bulkio::sri::YSTART
         *   @li @c bulkio::sri::YDELTA
         *   @li @c bulkio::sri::YUNITS
         *   @li @c bulkio::sri::MODE
         *   @li @c bulkio::sri::STREAMID
         *   @li @c bulkio::sri::BLOCKING
         *   @li @c bulkio::sri::KEYWORDS
         *
         * The @c HVERSION and @c STREAMID flags are not set in normal
         * operation.
         */
        int sriChangeFlags() const;

        /**
         * @brief  Sets the flags for which SRI fields have changed since the
         *         last read from the same stream.
         * @param flags  Bit mask representing changed fields.
         * @pre  Block is valid.
         * @see  sriChangeFlags()
         *
         * @note  This method is typically called by the input stream.
         */
        void sriChangeFlags(int flags);

        /**
         * @brief  Checks whether the input queue has flushed since the last
         *         read.
         * @returns  True if an input queue flush occurred. False if no flush
         *           has occurred.
         * @pre  Block is valid.
         *
         * An input queue flush indicates that the InPort was unable to keep up
         * with incoming packets for non-blocking streams and emptied the queue
         * to catch up.
         *
         * The input port reports a flush once, on the next queued packet. This
         * is typically reflected in the next %DataBlock read from any input
         * stream associated with the port; however, this does not necessarily
         * mean that any packets for that stream were discarded.
         */
        bool inputQueueFlushed() const;

        /**
         * @brief  Set the input queue flush flag.
         * @param flush  True if an input queue flush occurred. False if no
         *               flush has occurred.
         * @pre  Block is valid.
         * @see  inputQueueFlushed()
         *
         * @note  This method is typically called by the input stream.
         */
        void inputQueueFlushed(bool flush);

        /**
         * @brief  Add a time stamp in sorted order.
         * @param timestamp  The new time stamp.
         * @pre  Block is valid.
         *
         * Inserts @a timestamp into the list of timestamps, sorted in sample
         * offset order.
         *
         * If complex() is true, @a timestamp.offset is interpreted in terms of
         * complex samples.
         *
         * @note  No validity checks are performed on @a timestamp.
         */
        void addTimestamp(const SampleTimestamp& timestamp);

        /**
         * @brief  Returns the time stamp for the first sample.
         * @pre  Block is valid.
         */
        const BULKIO::PrecisionUTCTime& getStartTime() const;

        /**
         * @brief  Returns the time stamps for the sample data.
         *
         * If complex() is true, the offsets of the returned time stamps should
         * be interpreted in terms of complex samples.
         *
         * Valid %DataBlocks obtained by reading from an input stream are
         * guaranteed to have at least one time stamp, at offset 0. If the read
         * spanned more than one packet, each packet's time stamp is included
         * with the packet's respective offset from the first sample.
         *
         * When the %DataBlock is read from an input stream, only the first
         * time stamp may be synthetic. This occurs when the prior read did not
         * consume a full packet worth of data. In this case, the input stream
         * linearly interpolates the time stamp based on the stream's xdelta
         * value.
         *
         * @note  The list is returned as a temporary value. If you plan to
         *        iterate through the returned list, it must be stored in a
         *        local variable.
         */
        std::list<SampleTimestamp> getTimestamps() const;

        /**
         * @brief  Calculates the difference between the expected and actual
         *         value of the last time stamp
         * @returns  Difference, in seconds, between expected and actual value.
         * @pre  Block is valid.
         * @see  getMaxTimeDrift()
         * @see  xdelta()
         *
         * If this %DataBlock contains more than one time stamp, this method
         * compares the last time stamp to a linearly interpolated value based
         * on the initial time stamp, the StreamSRI xdelta, and the sample
         * offset.  This difference gives a rough estimate of the deviation
         * between the nominal and actual sample rates over the sample period.
         *
         * @note  If the SRI X-axis is not in units of time, this value has no
         *        meaning.
         */
        double getNetTimeDrift() const;

        /**
         * @brief  Calculates the largest difference between expected and
         *         actual time stamps in the block.
         * @returns  Greatest difference, in seconds, between expected and
         *           actual time stamps.
         * @pre  Block is valid.
         * @see  getNetTimeDrift()
         * @see  xdelta()
         *
         * If this %DataBlock contains more than one time stamp, this method
         * compares each time stamp to its linearly interpolated equivalent
         * time stamp, based on the initial time stamp, the StreamSRI xdelta,
         * and the sample offset. The greatest deviation is reported; this
         * difference gives a rough indication of how severely the actual
         * sample rate deviates from the nominal sample rate on a
         * packet-to-packet basis.
         *
         * @note  If the SRI X-axis is not in units of time, this value has no
         *        meaning.
         */
        double getMaxTimeDrift() const;

        /**
         * @brief  Checks block validity.
         * @returns  True if this block is invalid. False if the block is
         *           valid.
         * @see  operator unspecified_bool_type()
         *
         * Invalid (null) blocks do not contain any sample data or metadata. An
         * input stream read operation may return a null block if there is no
         * data available or the operation is interrupted.
         *
         * If this method returns true, no other methods except comparison or
         * assignment may be called.
         */
        bool operator! () const
        {
            return !_impl;
        }

    protected:
        /// @cond IMPL
        struct Impl;
        boost::shared_ptr<Impl> _impl;

        typedef boost::shared_ptr<Impl> DataBlock::*unspecified_bool_type;
        /// @endcond

    public:
        /**
         * @brief  Checks block validity.
         * @returns  Value convertible to true if this block is valid.
         *           Value convertible to false if this block is invalid.
         * @see  operator!()
         *
         * This operator supports affirmative boolean checks:
         * @code
         *   if (block) {
         *     // operate on block
         *   }
         * @endcode
         *
         * If this method returns true, any method may be called on this block.
         */
        operator unspecified_bool_type() const;
    };

    /**
     * @brief  Extended container for sample data types.
     *
     * %SampleDataBlock provides additional methods for accessing the stored
     * data as either real or complex samples.
     *
     * @warning  Do not declare instances of this template class directly in user
     *           code; the template parameter and class name are not considered
     *           API. Use the type-specific @c typedef instead, such as
     *           bulkio::FloatDataBlock, or the nested @c typedef BlockType from
     *           an %InputStream.
     *
     * @par  Upgrading to 2.2.0
     * Enhancements to BulkIO in REDHAWK 2.2.0 to support shared address space
     * components and shared memory IPC changed the ownership model of data
     * from strongly-owned to shared. As a result, methods that may provide
     * write access to the underlying data must make a local copy of the data
     * to preserve data integrity. For best performance, the buffer() and
     * cxbuffer() methods should be used in place of data() and cxdata() to
     * access block data:
     * @code
     *   const float* data = block.data();
     *   size_t count = block.size();
     * @endcode
     * becomes:
     * @code
     *   const redhawk::shared_buffer<float> buffer = block.buffer();
     *   const float* data = buffer.data();
     *   size_t count = buffer.size();
     * @endcode
     *
     * @par  Real vs. Complex Samples
     * Because BulkIO streams support both real and complex sample data, blocks
     * store data internally as an array of real samples, and provide methods
     * that allow the user to interpret the data as either real or complex.
     * When the complex mode changes, this is typically indicated with the
     * corresponding SRI change flag (see sriChangeFlags()). On a per-block
     * basis, the complex() method indicates whether the sample data is
     * intended to be handled as real or complex:
     * @code
     *   if (block.complex()) {
     *     const redhawk::shared_buffer<std::complex<float> > buffer = block.cxbuffer();
     *     for (size_t index = 0; index < buffer.size(); ++index) {
     *       // do something with buffer[index]
     *     }
     *   } else {
     *     const redhawk::shared_buffer<float> buffer = block.buffer();
     *     for (size_t index = 0; index < buffer.size(); ++index) {
     *       // do something with buffer[index]
     *     }
     *   }
     * @endcode
     */
    template <class T>
    class SampleDataBlock : public DataBlock<redhawk::shared_buffer<T> >
    {
    public:
        /// @brief  The native type of a real sample.
        typedef T ScalarType;

        /// @brief  The native type of a complex sample.
        typedef std::complex<T> ComplexType;

        /// @brief  The shared_buffer type for real data.
        typedef redhawk::shared_buffer<ScalarType> ScalarBuffer;

        /// @brief  The shared_buffer type for complex data.
        typedef redhawk::shared_buffer<ComplexType> ComplexBuffer;

        /**
         * @brief  Default constructor.
         * @see  InputStream::read
         * @see  InputStream::tryread
         *
         * Create a null block. This block has no data nor metadata associated
         * with it. No methods may be called on a null %SampleDataBlock except
         * for boolean checks, which will always indicate that the block is not
         * valid, and operator==, which returns true if and only if the other
         * %DataBlock is also null.
         *
         * SampleDataBlocks are typically obtained by reading from an input
         * stream.
         */
        SampleDataBlock();

        /**
         * @brief  Construct a %SampleDataBlock with a backing buffer.
         * @param sri    Stream descriptor for the data.
         * @param buffer The %shared_buffer containing sample data.
         * 
         * Creates a new, valid data block that references the data contained
         * in @a buffer.
         *
         * @note  This method is typically used by input streams.
         */
        explicit SampleDataBlock(const StreamDescriptor& sri, const ScalarBuffer& buffer=ScalarBuffer());

        /**
         * @deprecated  Do not use.
         */
        SampleDataBlock(const BULKIO::StreamSRI& sri, size_t size=0);

        /**
         * @brief  Copies this block's data and metadata.
         * @returns  A new block.
         *
         * Makes a complete copy of this block, which returns a unique block
         * that does not share this block's data or metadata.
         *
         * If this block is invalid, returns a new null block.
         */
        SampleDataBlock copy() const;

        /**
         * @deprecated  Do not use read/write access methods.
         */
        ScalarType* data();

        /**
         * @deprecated  Use buffer() for access to real sample data.
         */
        const ScalarType* data() const;

        /**
         * @brief  Gets the size of the data in terms of real samples.
         * @returns  Number of real samples.
         * @pre  Block is valid.
         * @see  cxsize()
         */
        size_t size() const;

        /**
         * @deprecated  Do not use.
         */
        void resize(size_t count);

        /**
         * @brief  Checks whether data should be interpreted as complex
         *         samples.
         * @returns  True if data is complex. False if data is real.
         * @pre  Block is valid.
         *
         * The sample data is considered complex if @c sri.mode is non-zero.
         *
         * If the data is complex, the offsets for the time stamps returned by
         * getTimestamps() are in terms of complex samples.
         */
        bool complex() const;

        /**
         * @deprecated  Do not use read/write access methods.
         */
        ComplexType* cxdata();

        /**
         * @deprecated  Use cxbuffer() for access to complex sample data.
         */
        const ComplexType* cxdata() const;

        /**
         * @brief  Gets the size of the data in terms of complex samples.
         * @returns  Number of complex samples.
         * @pre  Block is valid.
         * @see  size()
         */
        size_t cxsize() const;

        /**
         * @deprecated  Do not use.
         */
        void swap(std::vector<ScalarType>& other);

        /**
         * @brief  Read-only access to real sample data.
         * @returns  Read-only reference to %shared_buffer of real samples.
         * @pre  Block is valid.
         * @see  cxbuffer() const
         *
         * Interprets the internal buffer as real samples. The underlying data
         * may be shared with multiple consumers.
         *
         * To interpret the data as complex samples, use cxbuffer() const.
         */
        const ScalarBuffer& buffer() const;

        /**
         * @brief  Read-only access to complex sample data.
         * @returns  %shared_buffer of complex samples.
         * @pre  Block is valid.
         * @see  buffer() const
         *
         * Interprets the internal buffer as complex samples. The underlying
         * data may be shared with multiple consumers.
         *
         * To interpret the data as real samples, use buffer() const.
         */
        ComplexBuffer cxbuffer() const;

        using DataBlock<ScalarBuffer>::buffer;

    private:
        /// @cond IMPL
        typedef DataBlock<ScalarBuffer> Base;
        using Base::_impl;
        /// @endcond
    };

    typedef SampleDataBlock<int8_t>           CharDataBlock;
    typedef SampleDataBlock<CORBA::Octet>     OctetDataBlock;
    typedef SampleDataBlock<CORBA::Short>     ShortDataBlock;
    typedef SampleDataBlock<CORBA::UShort>    UShortDataBlock;
    typedef SampleDataBlock<CORBA::Long>      LongDataBlock;
    typedef SampleDataBlock<CORBA::ULong>     ULongDataBlock;
    typedef SampleDataBlock<CORBA::LongLong>  LongLongDataBlock;
    typedef SampleDataBlock<CORBA::ULongLong> ULongLongDataBlock;
    typedef SampleDataBlock<CORBA::Float>     FloatDataBlock;
    typedef SampleDataBlock<CORBA::Double>    DoubleDataBlock;
    typedef DataBlock<redhawk::shared_bitbuffer> BitDataBlock;
    typedef DataBlock<std::string>            StringDataBlock;

}  // end of bulkio namespace

#endif
